Project Penney 2 Million Deck Generation: Chris Tillotson and Katy Lenshin

Method 1: Generates a numpy array of numpy arrays of 'decks of cards.' The decks of cards are actually represented by the integers 0 and 1 and encoded into np.uint8, and these 'decks of cards' are saved in the (incredibly compressive) .npz file-types with a specified maximum of 500,000 decks per file.

Method 2: Generates a numpy array of strings, each string being '0' or '1', representing the deck. Then, a '1' is appended to a version of this array as a list, then all the strings are joined into one long string, then that string is turned into an integer (but a regular integer type, not np.uint8). All of these integers are stored in a very large numpy array, in a similar manner to the smaller 52 individual integer long numpy arrays are stored in a very large numpy array. They are then saved into npz file-types with a specified maximum of 500,000 decks per file.

Which method we prefer, and why:
These two methods to have an interesting tradeoff: Method 1 has better storage efficiency, likely due to the np.uint8 (Long Integer) type, while Method 2 is faster and more memory efficient. However, we value storage, especially at the scale of 2 million decks, over memory usage and speed (given that we do not intend to regenerate decks often), so we think Method 1 is superior. Additionally, we predict that Method 1 will be easier to read once it is used for scoring, because data in Method 2 will first need to be converted back into strings, the leading 1 removed, then split, in order to differentiate the order of cards, while data in Method 1 already exists as split integers. 

Explanation of results:
storage_mb is the storage size of all decks generated by a particular set of unique parameters: number of decks and method used, in megabytes.
memory_mb is the memory size of all decks generated by a particular set of unique parameters: number of decks and method used, in megabytes.
time_taken is the time taken to create and store all decks generated by a particular set of unique parameters: number of decks and method used, in seconds.


=== Method: method_1_funct | num_decks: 1000 ===
storage_mb      | mean=      0.01 | median=      0.01 | std=      0.00
memory_mb       | mean=      0.05 | median=      0.05 | std=      0.00
time_taken      | mean=      0.02 | median=      0.02 | std=      0.00

=== Method: method_2_funct | num_decks: 1000 ===
storage_mb      | mean=      0.02 | median=      0.02 | std=      0.00
memory_mb       | mean=      0.01 | median=      0.01 | std=      0.00
time_taken      | mean=      0.01 | median=      0.01 | std=      0.00

=== Method: method_1_funct | num_decks: 10000 ===
storage_mb      | mean=      0.08 | median=      0.08 | std=      0.00
memory_mb       | mean=      0.52 | median=      0.52 | std=      0.00
time_taken      | mean=      0.19 | median=      0.19 | std=      0.01

=== Method: method_2_funct | num_decks: 10000 ===
storage_mb      | mean=      0.20 | median=      0.20 | std=      0.00
memory_mb       | mean=      0.08 | median=      0.08 | std=      0.00
time_taken      | mean=      0.10 | median=      0.10 | std=      0.00

=== Method: method_1_funct | num_decks: 100000 ===
storage_mb      | mean=      0.83 | median=      0.83 | std=      0.00
memory_mb       | mean=      5.20 | median=      5.20 | std=      0.00
time_taken      | mean=      1.87 | median=      1.87 | std=      0.02

=== Method: method_2_funct | num_decks: 100000 ===
storage_mb      | mean=      2.03 | median=      2.03 | std=      0.00
memory_mb       | mean=      0.80 | median=      0.80 | std=      0.00
time_taken      | mean=      0.99 | median=      0.99 | std=      0.01
